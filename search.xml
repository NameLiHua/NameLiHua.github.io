<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/26/hello-world/"/>
      <url>/2022/01/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>测试文章</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>边缘检测</title>
      <link href="/2022/01/24/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
      <url>/2022/01/24/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h1><hr><p>实现思路:</p><ol><li><p>使用高斯滤波器，以平滑图像，滤除噪声。</p></li><li><p>计算图像中每个像素点的梯度强度和方向。</p></li><li><p>应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。</p></li><li><p>应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。</p></li><li><p>通过抑制孤立的弱边缘最终完成边缘检测。</p></li></ol><p><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/486103921220169.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>索贝尔算子</title>
      <link href="/2022/01/24/%E7%AE%97%E5%AD%90/"/>
      <url>/2022/01/24/%E7%AE%97%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="索贝尔算子"><a href="#索贝尔算子" class="headerlink" title="索贝尔算子"></a>索贝尔算子</h1><h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><p>索贝尔算子边缘算子所采用的算法是先进行加权平均，然后进行微分运算，算子的计算方法如下：</p><p><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E7%AE%97%E5%AD%90.md/412485220243405.svg"><br><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E7%AE%97%E5%AD%90.md/73415520236951.svg"></p><p>Sobel算子垂直方向和水平方向的模板如下图所示，前者可以检测出图像中的水平方向的边缘，后者则可以检测图像中垂直方向的边缘。实际应用中，每个像素点取两个模板卷积的最大值作为该像素点的输出值，运算结果是一副边缘图像。</p><table><thead><tr><th>-1</th><th>-2</th><th>-1</th><th></th><th>-1</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td></td><td>-2</td><td>0</td><td>2</td></tr><tr><td>1</td><td>2</td><td>1</td><td></td><td>-1</td><td>0</td><td>1</td></tr></tbody></table><p>该算子包含两组3x3的矩阵，分别为横向及纵向，将之与图像作平面卷积，即可分别得出横向及纵向的亮度差分近似值。如果以A代表原始图像，Gx及Gy分别代表经横向及纵向边缘检测的图像，其公式如下:<br><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E7%AE%97%E5%AD%90.md/308051221220615" alt="&lt;center&gt;核心公式&lt;/center&gt;"></p><p>图像的每一个像素的横向及纵向梯度近似值可用以下的公式结合，来计算梯度的大小。<br><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E7%AE%97%E5%AD%90.md/396461321223119.svg"><br>然后可用以下公式计算梯度方向。<br><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E7%AE%97%E5%AD%90.md/597451321232066.svg"><br>在以上例子中，如果以上的角度θ等于零，即代表图像该处拥有纵向边缘，左方较右方暗。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><mark>主要方法如下:</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.Sobell(src,ddepth,dx,dy,ksize)</span><br></pre></td></tr></table></figure><p><mark>参数分析:</mark></p><ul><li>ddepth : 图像的深度</li><li>dx,dy ：分别表示水平和竖直方向</li><li>ksize ：Sobel算子的大小</li></ul><p><mark>示例分析:</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv_show</span>(<span class="params">name,img</span>):</span></span><br><span class="line">    cv2.imshow(name,img)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&quot;d:\\shili3.png&quot;</span>,cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算x</span></span><br><span class="line">sobelx = cv2.Sobel(img,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">3</span>)</span><br><span class="line">sobelx = cv2.convertScaleAbs(sobelx)<span class="comment">#取绝对值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算y</span></span><br><span class="line">sobely = cv2.Sobel(img,cv2.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize=<span class="number">3</span>)</span><br><span class="line">sobely = cv2.convertScaleAbs(sobely)<span class="comment">#取绝对值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#分别计算x,y后，求和</span></span><br><span class="line">sobelxy = cv2.addWeighted(sobelx,<span class="number">0.5</span>,sobely,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line">cv_show(<span class="string">&quot;sobelxy&quot;</span>,sobelxy)</span><br></pre></td></tr></table></figure><p>::: alert-info<br>白到黑是整数，黑到白就是负数了，所有的负数会被截断成0。所以要取绝对值<br>:::</p><p><mark>效果示意如下:</mark><br>上边那个是原图(灰度处理后),下边那个是运算结果<br><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E7%AE%97%E5%AD%90.md/199113721225560.png" alt="&lt;center&gt;原图(灰度处理后)&lt;/center&gt;"></p><p><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E7%AE%97%E5%AD%90.md/218053521224951.png" alt="&lt;center&gt;Sobel算子图&lt;/center&gt;"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>形态学处理</title>
      <link href="/2022/01/24/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86/"/>
      <url>/2022/01/24/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="形态学处理"><a href="#形态学处理" class="headerlink" title="形态学处理"></a>形态学处理</h1><hr><h2 id="膨胀与腐蚀简介"><a href="#膨胀与腐蚀简介" class="headerlink" title="膨胀与腐蚀简介"></a>膨胀与腐蚀简介</h2><blockquote><p>主要功能如下：</p><ul><li>消除噪声</li><li>分割（isolate)出独立的图像像中连接相邻的元素</li><li>寻找图像中明显的极大值或极小值区域</li><li>求出图像的梯度</li></ul></blockquote><p><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86.md/274483020235848.png" alt="&lt;center&gt;原图&lt;/center&gt;"></p><h2 id="膨胀-黑色萎缩-白色膨胀"><a href="#膨胀-黑色萎缩-白色膨胀" class="headerlink" title="膨胀(黑色萎缩,白色膨胀)"></a>膨胀(黑色萎缩,白色膨胀)</h2><p><mark>主要效果:</mark>就是把白色的部分增多,黑色部分减少,简称”白内胀”</p><p><mark>原理分析如下:</mark></p><blockquote><p>按数学方面来说，膨胀或者腐蚀操作就是将图像(或图像的一部分区域，我们称之为A)与核(我们<br>称之为B)进行卷积。<br>核可以是任何的形状和大小，它拥有一个单独定义出来的参考点，我们称其为锚点(anchorpoint)。<br>多数情况下，核是一个小的中间带有参考点和实心正方形或者圆盘，其实，我们可以把核视为模板或者掩码。</p></blockquote><hr><blockquote><p>而膨胀就是求局部最大值的操作，核B与图形卷积，<br>即计算核B覆盖的区域（体现局部）的像素点的最大值，<br>并把这个最大值赋值给参考点指定的像素。这样就会使图像中的高亮区域逐渐增长。</p></blockquote><p>示例代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.dilate(src,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><mark>参数解析如下:</mark></p><ul><li><input disabled="" type="checkbox"> dst是膨胀后所输出的目标图像，该图像和原始图像具有同样的类型和大小。</li><li><input disabled="" type="checkbox"> src是需要进行膨胀的原始图像，图像的通道数可以是任意的。</li><li><input disabled="" type="checkbox"> 但是要求图像的深度必须是cV_8u、CV_16U、CV_16S、CV_32F、CV_64F中的一种。</li><li><input disabled="" type="checkbox"> kernel代表腐蚀操作时所采用的结构类型。</li></ul><p><mark>示例分析:</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img = imread(<span class="string">r&#x27;D:\\fushi2.png&#x27;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">dilate = cv2.dilate(img,kernel,iterations = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;erosion&#x27;</span>,dilate)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86.md/510612920239293.png" alt="&lt;center&gt;膨胀后的图&lt;/center&gt;"></p><h2 id="腐蚀-白色色萎缩-黑色膨胀"><a href="#腐蚀-白色色萎缩-黑色膨胀" class="headerlink" title="腐蚀(白色色萎缩,黑色膨胀)"></a>腐蚀(白色色萎缩,黑色膨胀)</h2><p><mark>主要效果:</mark>可以去白色的毛刺和小小的玩意,随着腐蚀的多次迭代,白色框框会越来越小,黑色把白色腐蚀掉,简称</p><p>示例代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.erode(src,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><mark>参数解析:</mark></p><ul><li><input disabled="" type="checkbox"> dst是腐蚀后所输出的目标图像，该图像和原始图像具有同样的类型和大小。</li><li><input disabled="" type="checkbox"> src是需要进行腐蚀的原始图像，图像的通道数可以是任意的。但是要求图像的深度必须是cV_8u、CV_16U、CV_16S、CV_32F、CV_64F中的一种。</li><li><input disabled="" type="checkbox"> kernel代表腐蚀操作时所采用的结构类型。它可以自定义生成，也可以通过函数cv2.getStructuringElement()生成。</li><li><input disabled="" type="checkbox"> iterations代表迭代的次数,迭代次数越多,腐蚀效果越强</li></ul><p><mark>实例分析:</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img = imread(<span class="string">r&#x27;D:\\fushi.png&#x27;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erosion = cv2.erode(img,kernel,iterations = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;erosion&#x27;</span>,erosion)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86.md/515072820246624.png" alt="&lt;center&gt;腐蚀后的图&lt;/center&gt;"></p><h2 id="闭运算-先膨胀，再腐蚀"><a href="#闭运算-先膨胀，再腐蚀" class="headerlink" title="闭运算(先膨胀，再腐蚀)"></a>闭运算(先膨胀，再腐蚀)</h2><p><mark>主要效果:</mark>不知道有啥用</p><p><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86.md/358613220231602.png" alt="&lt;center&gt;闭运算后的图&lt;/center&gt;"></p><h2 id="梯度运算"><a href="#梯度运算" class="headerlink" title="梯度运算"></a>梯度运算</h2><p>::: alert-info</p><p>梯度 = 膨胀 - 腐蚀</p><p>:::</p><p>可以先对比这张图的膨胀图和腐蚀图:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pie = cv2.imread(<span class="string">&quot;pie.png&quot;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">7</span>,<span class="number">7</span>),np.uint8)</span><br><span class="line">dilate = cv2.dilate(pie,kernel,iterations = <span class="number">5</span>)</span><br><span class="line">erosion = cv2.erode(pie,kernel,iterations = <span class="number">5</span>)</span><br><span class="line">res = np.hstack((dilate,erosion))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;res&#x27;</span>,res)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86.md/234553920249482.png" alt="&lt;center&gt;腐蚀膨胀效果对比图&lt;/center&gt;"></p><p>梯度运算:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">r&quot;D:\\shili3.png&quot;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">gradient = cv2.morphologyEx(img,cv2.MORPH_GRADIENT,kernel)</span><br><span class="line"></span><br><span class="line">cv_show(<span class="string">&#x27;gradient&#x27;</span>,gradient)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86.md/340804220247086.png" alt="&lt;center&gt;梯度运算结果图&lt;/center&gt;"></p><p>看起来还是很奇怪的</p><h2 id="礼帽-黑帽"><a href="#礼帽-黑帽" class="headerlink" title="礼帽,黑帽"></a>礼帽,黑帽</h2><p>::: alert-info<br>礼帽 = 原始输入-开运算结果<br>黑帽 = 闭运算-原始输入<br>:::</p><p><mark>礼帽:</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">r&quot;D:\\shili3.png&quot;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">tophat = cv2.morphologyEx(img,cv2.MORPH_TOPHAT,kernel)</span><br><span class="line"></span><br><span class="line">cv_show(<span class="string">&#x27;tophat&#x27;</span>,tophat)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86.md/114804820244588.png" alt="&lt;center&gt;礼帽效果图&lt;/center&gt;"><br><mark>黑帽:</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">r&quot;D:\\shili3.png&quot;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">blackhat = cv2.morphologyEx(img,cv2.MORPH_BLACKHAT,kernel)</span><br><span class="line"></span><br><span class="line">cv_show(<span class="string">&#x27;blackhat&#x27;</span>,blackhat)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/i-love-baba/markdown-picture/raw/master/py_opencv/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86.md/579944920225829.png" alt="&lt;center&gt;黑帽效果图&lt;/center&gt;"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阈值和平滑处理</title>
      <link href="/2022/01/23/%E9%98%88%E5%80%BC%E5%92%8C%E5%B9%B3%E6%BB%91%E5%A4%84%E7%90%86/"/>
      <url>/2022/01/23/%E9%98%88%E5%80%BC%E5%92%8C%E5%B9%B3%E6%BB%91%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="阈值和平滑处理"><a href="#阈值和平滑处理" class="headerlink" title="阈值和平滑处理"></a>阈值和平滑处理</h1><h2 id="阈值处理"><a href="#阈值处理" class="headerlink" title="阈值处理"></a>阈值处理</h2><p>可以直接参考这个函数;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret,dst = cv2.threshold(src,thresh,maxval,<span class="built_in">type</span>)</span><br></pre></td></tr></table></figure><ul><li>src:输入图。只能输入单通道图像。通常来说为灰度图</li><li>dst:输出图</li><li>thresh:阈值</li><li>maxval:当像素值超过了阈值(或者小于阈值，根据type来决定)，所赋予的值</li><li>type:二值化操作的类型，包含以下5种类型:</li><li>cv2.THRESH_BINARY; cv2.THRESH_BINARY_INV; cv2.THRESH_TRUNC;</li><li>cv2.THRESH_TOZERO_INUNC;cv2.THRESH_TOZERO_INV</li><li>cv2.THRESH_BINARY 超过阈值部分取maxval(最大值)，否则取O</li><li>cv2.THRESH_BINARY_INV THRESH_BINARY的反转</li><li>cv2.THRESH_TRUNC大于阈值部分设为阈值,否则不变</li><li>cv2.THRESH_TOZERO大于阈值部分不改变，否则设为0</li><li>cv2.THRESH_TOZERO_INV THRESH_TOZERO的反转</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">r&quot;D:\\draw.png&quot;</span>,cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret,thresh1 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO_INV)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>,<span class="string">&#x27;BINARY&#x27;</span>,<span class="string">&#x27;BINARY_INV&#x27;</span>,<span class="string">&#x27;TRUNC&#x27;</span>,<span class="string">&#x27;TOZERO&#x27;</span>,<span class="string">&#x27;TOZERO_INV&#x27;</span>]</span><br><span class="line">images = [img,thresh1,thresh2,thresh3,thresh4,thresh5]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="平滑处理"><a href="#平滑处理" class="headerlink" title="平滑处理"></a>平滑处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">r&quot;girl.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="平滑处理-1"><a href="#平滑处理-1" class="headerlink" title="平滑处理"></a>平滑处理</h2><p>有多种处理方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#均值滤波</span></span><br><span class="line"><span class="comment">#简单的平均卷积操作</span></span><br><span class="line">blur = cv2.blur(img,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">cv2.imshow(‘blur’,blur)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方框滤波</span></span><br><span class="line"><span class="comment">#基本等同于均值滤波，不过可以选择归一化</span></span><br><span class="line"><span class="comment">#似乎是normalize为true就是归一化,false就不是</span></span><br><span class="line">box = cv2.boxFilter(img,-<span class="number">1</span>,(<span class="number">3</span>,<span class="number">3</span>),normalize=<span class="literal">True</span>)</span><br><span class="line">cv2.imshow(‘box’,box)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#高斯滤波</span></span><br><span class="line"><span class="comment">#满足高斯分布，相当于更加重视中间的</span></span><br><span class="line">aussian = cv2.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">1</span>)</span><br><span class="line">cv2.imshow(“aussian”,aussian)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#中值分布</span></span><br><span class="line"><span class="comment">#相当于用中值代替</span></span><br><span class="line">median = cv2.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">cv2.imshow(“median”,median)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
